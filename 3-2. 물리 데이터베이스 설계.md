# 3.데이터베이스 구축
## 2. 물리 데이터베이스 설계
### 2-1. 물리 환경 조사 분석

**시스템 조사 및 분석 목표**
- 기존 시스템을 분석하여 업무 영역과 시스템 영역으로 구분하여 용어 사전 기반으로 명명 규칙을 파악한다
- 데이터베이스와 관련된 요소들을 파악해 구조, 이중화 구성, 분산 구조, 암호화, 접근 제어, DB 암호화에 대한 시스템 조사, 분석을 진행한다

**비즈니스 도메인 및 명명 규칙 분석**
|분석 요소|설명|
|--|--|
|비즈니스 도메인|- 모델링 시의 도메인은 객체 Entity 타입이 속성에 대한 데이터 타입 및 크기, 제약을 지정함|
|명명 규칙|- 데이터 명명 규칙 : 비즈니스/시스템과 관련됨 + 물리 데이터 모델 각각의 요소에 적용해야 함<br>- 데이터 명명 규칙의 우선 파악 필요|
|데이터(용어)사전|- 비즈니스 기업 전사 차원 시스템의 일관성 있는 명명 규칙, I/F Interface 제공을 위해 <br>- 논리명 Logical Name<br>- 물리명 Physical Name<br>- 용어 정의 Definition<br>- 을 정의한 표준체계|

**시스템의 물리적 체계 분석**
- 데이터베이스의 설치에 영향을 줄 수 있는 하드웨어 및 운영체제, DBMS 버전, 파라미터 정보 등을 분석하는 절차
- 데이터베이스의 특성, 스토리지 유형, 서버, 네트워크 특성을 파악하고 숙지해야함

|분석 요소|설명|
|--|--|
|하드웨어 지원|CPU, Memory, Disk, I/O, Controller, Network 자원 등의 정보를 분석 진행함|
|운영체제<br>DBMS 버전|운영 환경과 데이터베이스 버전, 설치되는 데이터베이스의 인스턴스 관리 방법 등에 대한 확인을 진행함|
|데이터베이스 파라미터 정보 파악|DBMS의 파라미터 : DBMS별로 차이가 있으며 관리 방법도 상이함<br>- DBMS의 저장공간, 메모리 관리 방법, 옵티마이저 설정 등에 대한 정보 파악 및 고려 필요|

**파라미터 Parameter**
- 실행 환경과 프로그램 사이에 주고받는 정보를 일시적으로 저장하는 역할
- 묵시적/명시적 파라미터

**데이터베이스 생명주기 Database Life Cycle**
- 데이터베이스 : 정보 시스템의 기초
- 요구 조건 분석, 설계, 구현, 운영, 감시 및 개선 단계를 통해 구성됨
- 물리적 데이터베이스 설계 요소 : 스토리지, 분산 데이터베이스, 데이터베이스 이중화, 암호화 및 접근 제어에 대한 설계 필요

**데이터베이스 관리 요소**
- 데이터베이스 운영과 관련된 요소 : 사용자 관리 기법 및 정책, 백업/복구 기법, 보안 관리 정책 포함
- 데이터베이스 운영 보장을 위해 데이터베이스 구조, 이중화 구성, 분산 구조, 접근 제어 및 DB 암호화 등에 대한 범위 및 특성 파악 필요

|관리 요소|설명|
|--|--|
|DBMS 구조|데이터베이스에 따라 달라질 수 있으며 저장 및 안전한 관리를 위해 구조의 이해가 필요함|
|이중화 구성|장애 발생 시 데이터베이스를 보호하기 위해 중복 갱신 등의 방법을 이용함|
|분산 구조|네트워크를 이용해 단일한 데이터베이스 관리 시스템으로 이용할 수 있으며 데이터베이스의 복제 및 분산을 통해 향상된 성능 제공, 물리적 재해 대응 및 유실을 방지할 수 있음|
|접근 제어|WEB를 통한 접근 제어, DBMS 권한 소유자에 의한 접근 제어 등 안정적 관리를 유지하기 위한 관리 필수 요소|
|DB 암호화|데이터 자체에 대한 암호화 및 암호 키에 대한 인증 및 권한 관리로 구성됨|

**데이터베이스 이중화 Database Replication**
- 오류로 데이터베이스 서비스 중단이나 물리적 손상이 발생한 경우 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것
- Eager : 데이터 변경이 발생하면 즉시 적용되는 기법
- Lazy : 트랜잭션이 종료되면 데이터 변경 사항을 새로운 트랜잭션으로 전달함

**데이터베이스 백업 기법**
- 데이터베이스 장애 시 복구를 위해 진행하는 작업으로 복구 수준에 따라 백업의 종류 및 범위가 결정됨

|관점|방법|설명|
|--|--|--|
|백업 주체|DBMS 논리 백업|DBMS 지원 유틸리티 이용|
||OS 물리 백업|로그 파일 백업 사용|
|||로그 파일 백업 없음|
|데이터 범위|전체 백업|데이터 전체 백업|
||차분 백업|이전 백업 이후 변경 부분만 백업|
||증분 백업|전체 백업 이후 변경분이 누적되어 백업|

### 2-2. 저장 공간 설계

**테이블 설계**
- 데이터베이스를 구성하는 가장 기본적인 객체
- 행 Rows과 열 Column으로 구성됨
- 데이터베이스에 저장되는 데이터는 모두 테이블에 저장됨

**테이블 유형**
|구분|설명|
|--|--|
|일반 유형 테이블<br>Heap-Organized Table|- 상용 DBMS에서 사용<br>- 테이블 내의 저장 위치는 해당 로우가 저장될 때 결정됨|
|클러스터 인덱스 테이블<br> Clustered Index Table|- 기본 키(PK, Primary Key) 및 인덱스 키 값 등의 순서를 기반으로 데이터가 저장되는 테이블<br>- B-Tree leaf node에 RowID가 아닌 데이터 페이지가 저장되는 구조|
|파티셔닝 테이블<br>Partitioned Table|- 파티션 키 : 파티션 생성 / 테이블 데이터 저장 구분<br>- 대용량 데이터 저장 시 많이 사용됨|
|외부 테이블<br>External Table|- 데이터베이스 내의 일반 테이블 형태로 이용할 수 있는 데이터베이스 객체<br>- DW(Data Warehouse)의 ETL 작업에 유용하게 사용할 수 있는 테이블|
|임시 테이블<br>Temporary Table|- 트랜잭션/세션별 테이블 생성 및 데이터 저장/처리 가능한 테이블<br>- 트랜잭션이나 세션이 사라지면 같이 사라짐(타 세션 공유 불가)|

**파티셔닝**
- 큰 테이블/인덱스를 물리적 분할함

**컬럼 Column**
- 테이블을 구성하는 기본 요소
- 데이터 타입, 길이 등을 정의할 수 있음
- 데이터 타입 Data type : 데이터 일관성 유지를 위한 가장 기본적 기능 / 표준화된 도메인 정의 시 그에 따라 데이터 타입/길이 정의
- 비교 연산에서 두 컬럼 사이의 데이터 타입/길이가 상이할 경우 DBMS에서 내부 형변환 이후 연산 수행 > 컬럼이 상호 참조일 경우 가능한 동일 데이터 타입 및 길이를 사용해 인덱스 사용/실행 계획을 예측함

**DBMS별 물리적 순서 조정 특성**
|특징|설명|
|--|--|
|Oracle|- 인덱스를 구성하는 모든 컬럼 값이 Null인 로우는 인덱스를 저장하지 않아 저장 공간을 절약하고 테이블 full scan을 쉽게 유도할 수 있음|
|SQL 서버|- Null도 하나의 값으로 인식<br>- Null을 이용한 인덱스 스캔 가능|

**데이터 타입/길이 지정 시 고려 사항**
- 데이터 타입(가변 길이) : 예상 최대 길이 지정
- 데이터 타입(고정 길이) : 최소 길이 지정
- 소수점 이하 자리 수 : 반올림 후 저장

**컬럼 데이터 타입에 따른 물리적 순서 고정**
- 가변 길이 컬럼 : 뒤쪽 배치
- 고정 길이 컬럼 : Not Null인 컬럼 앞쪽 배치
- Null값이 많을 것 같은 컬럼 : 뒤쪽 배치

**테이블 스페이스**
- 저장되는 내용에 따라 테이블, 인덱스, 임시 데이터 등으로 구분하여 설계함
- 백업 및 공간 확장 단위인 물리적 파일 크기의 적정한 유지가 가능
- 데이터 용량을 관리하는 단위로 이용 가능

**테이블 스페이스 설계 고려사항**
- 테이블에 저장되는 테이블 스페이스는 **업무별**로 지정함
- **테이블/인덱스 분리**하여 저장됨
- 대용량 테이블 : 독립적 테이블 스페이스 이용
- LOB Large Object : 독립적인 공간 지정

**데이터베이스 용량 설계 목적**
- 정확한 데이터 용량 예측 : 저장 공간 효과적 사용, 확장성 및 가용성 확보
- 하드웨어 특성 고려 설계 : 디스트 병목 예방
- 디스크 I/O 분산 용량 설계 : 접근성 향상
- 용량 설계 : 테이블 및 인덱스에 적합한 저장 옵션 지정 가능

**테이블 저장 옵션 고려 사항**
- 초기 사이즈, 증가 사이즈
- 트랜잭션 관련 옵션(Commit이 일어나기 전 Temporary Data Size)
- 최대 사이즈, 자동 증가

### 2-3. 트랜잭션 분석

**트랜잭션 Transaction**
- 데이터베이스에서 행해지는 작업의 논리적 단위
- 분석 목적 : 테이블에서 발생하는 트랜잭션 양에 따라 데이터베이스 용량을 산정하여 DB 구조를 최적화함

**트랜잭션 분석 활용**
|활용 방법|설명|
|--|--|
|용량 산정의 근거 자료|테이블에 생성된 트랜잭션 분석 > 저장되는 데이터 양 유추> 데이터베이스 용량 산정|
|디스크 구성의 이용|트랜잭션 분석 결과 이용 > 프로세스가 과도하게 발생하는 테이블에 대해 디스크 분산 > 성능 향상|
|채널의 분산|데이터베이스와 연결되는 채널 분산 > 대기 현상 / Time-Out 등 예방|

**트랜잭션 격리 수준 Transaction Isolation Level**
- 동시에 여러 트랜잭션이 처리될 때 특정 트랜지션이 다른 트랜잭션에서 변경/조회하는 데이터를 볼 수 있도록 허용할지를 결정하는 것
- ACID : 원자성 일관성 고립성 지속성
- 등장 이유 : ACID 특성을 지나치게 고려 시 동시성에 대한 성능이 저하될 수 있음 > 트랜잭션 격리 수준을 나누어 동시성 성능을 지키려고 함
- 높은 트랜잭션 격리 수준 단점
  1. 동시성 처리에 대한 성능 저하
  2. Deadlock 발생 확률 증가
  3. Lock으로 인한 시스템 오버헤드 증가
- 트랜잭션 격리 수준을 적용하지 않았을 때 문제점
  1. Non-Repetable Read
  2. Dirty Read
  3. Phantom Read

**데이터베이스 무결성**
- 절차적, 선언적 방법 및 동시성 제어, 회복 기법을 이용해 데이터의 정확성, 일관성, 유효성, 신뢰성 등과 무효 갱신으로부터 데이터를 보호하기 위한 기법
- 개체, 참조, 속성, 사용자 정의, 키 무결성 
- 일관성 : 상태가 항상 같아야 함 > 이전의 상태에 오류가 없을 때 이후의 상태에도 오류가 없어야 하며 오류가 없는 상태 : 무결성
- 정확성, 일관성, 유일성, 신뢰성 상태 통칭

**데이터 무결성 유지 방법**
|구분|선언적 방법|절차적 방법|
|--|--|--|
|개념|DBMS 기능으로 무결성 구현|애플리케이션에서 무결성 구현|
|구현 방법|DDL문으로 구현|서버상에서 DML문으로 구현|
|무결성 점검|DBMS|프로그램|
|장점|절차적 데이터 무결성보다 오류 발생 가능성이 적음|여러 번 반복 사용 시 편리|
|단점|성능에 영향을 줄 수 있음|오류가 발생할 수 있는 가능성 존재|
|사례|- DDL(Create, Alter)<br>- Primary Key, Foreign Key|- Trigger, Stored Procedure<br>- Application|

**데이터베이스 무결성 종류**
|무결성 종류|설명|방법|
|--|--|--|
|실체 무결성<br>개체 무결성|- 반드시 보장되어야 하는 성질<br>- 실체에서 개체의 유일성을 보장하기 위한 무결성<br>- 기본 키의 값이 NULL값이 아닌 원자값을 가짐|- PK(Primary Key), Unique 제약 조건 등을 이용|
|영역 무결성<br>속성 무결성|- 컬럼 데이터 타입, 길이, 유효값이 일관되게 유지되어야 한다는 성질|- 데이터 타입/길이<br>- 유효값 : Check/NOT NULL|
|참조 무결성|- 두 실체 사이의 관계 규칙을 정의하기 위한 제약 조건<br>- 데이터가 입력/수정/삭제될 때 두 실체의 튜플들 사이의 정합성과 일관성 유지에 사용|- 입력/수정/삭제 참조 무결성 Default|
|사용자 정의 무결성|다양하게 정의될 수 있는 비즈니스 규칙이 데이터적으로 일관성을 유지하는 성질|- Trigger<br>- 사용자 정의 데이터 타입<br>User Define Data Type|
|키 무결성|애트리뷰트에 중복된 값이 존재하면 안된다는 조건|기본 키, Unique Key로 릴레이션 내에 중복된 값을 허용하지 않음|

**데이터 무결성 강화**
- 데이터 무결성 > 데이터 품질 직접적 영향
- 목적 : 품질 확보/유지
- 데이터베이스 구축 단계부터 확보해야함
- 애플리케이션 내부 : 상호 간 유지해야 할 정합성 처리

|무결성 강화 방법|설명|장점|단점|
|--|--|--|--|
|애플리케이션|- 데이터를 조작하는 프로그램 내에 생성/수정/삭제 시 무결성 조건 검증 코드 추가|- 사용자 정의 같은 복잡한 무결성 조건 정의|- 관리 어려움 : 소스 코드에 분산됨<br>- 적정성 검토 어려움 : 개별적으로 수행됨|
|데이터베이스<br>트리거|- 트리거 이벤트 시 저장 SQL을 실행하여 무결성 조건을 실행함|- 통합 관리 가능<br>- 복잡한 요구 조건 구현 가능|- 운영 중 변경 어려움<br>- 사용상 주의 필요|
|제약 조건<br>Constraints|- 데이터베이스 제약 조건을 선언함|- 통합 관리/간단 선언을 통한 구현/변경 용이<br>- 유효/무효 상태 변경 가능<br>- 원천적으로 잘못된 데이터 발생 방지|- 복잡한 제약 조건 구현 어려움<br>- 예외 처리 불가능|

**회복 기법**
- 데이터베이스의 운용 중 예기치 못한 실패 Failure 발생 시 데이터베이스를 장애 발생 이전의 일관된 상태 Consistent state로 되돌리는 기술

**REDO/UNDO**
|구분|설명|
|--|--|
|REDO|- 재수행<br>- 데이터베이스 내용 자체가 손상이 된 경우 최근 복제본을 적재한 후 로그 정보를 이용하여 이후 일어난 변경만을 재실행하여 회복함|
|UNDO|- 원상복구<br>- 데이터베이스 내용 자체는 손상되지 않았지만 변경 중이거나 변경된 내용에 대한 신뢰성을 잃어버린 경우 모든 변경 내용을 취소하여 복원함|

**회복 기법 유형**
<p align="center"><img src="https://github.com/7ahyeon/EIP-study/assets/107123698/628ea6b1-8581-4837-ab65-277e60d102eb" width="650" /></p>

